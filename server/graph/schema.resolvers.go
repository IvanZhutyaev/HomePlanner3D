package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"ServerBTI/graph/assistant"
	"ServerBTI/graph/model"
	"ServerBTI/internal/models"
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.User, error) {
	user_DataBase := &models.User{
		Login:    input.Login,
		Username: input.Username,
		Password: input.Password,
		Email:    input.Email,
		Birthday: input.Birthday,
	}
	user_graphql := &model.User{
		ID:       fmt.Sprintf("%d", user_DataBase.ID),
		Username: user_DataBase.Username,
		Email:    user_DataBase.Email,
		Login:    user_DataBase.Login,
	}

	if err := r.DB.Create(user_DataBase).Error; err != nil {
		return user_graphql, err
	}
	return user_graphql, nil
}

// CreatePlanningProject is the resolver for the createPlanningProject field.
func (r *mutationResolver) CreatePlanningProject(ctx context.Context, input model.PlanningProjectInput) (*model.PlanningProject, error) {
	var decision string = "pending"

	var sb strings.Builder
	sb.WriteString("Проанализируй проект перепланировки и верни JSON с ключами is_valid, decision, justification, technical_basis, limitations_risks, clarification_needed.")
	sb.WriteString(" Адрес: ")
	sb.WriteString(input.Plan.Address)
	sb.WriteString("; Площадь: ")
	sb.WriteString(fmt.Sprintf("%f", input.Plan.Area))
	sb.WriteString("; Высота потолка: ")
	sb.WriteString(fmt.Sprintf("%f", input.Plan.CeilingHeight))
	if input.Geometry != nil {
		sb.WriteString("; Комнат: ")
		sb.WriteString(fmt.Sprintf("%d", len(input.Geometry.Rooms)))
		for _, r := range input.Geometry.Rooms {
			sb.WriteString("; Комната ")
			if r.ID != nil {
				sb.WriteString(*r.ID)
			}
			sb.WriteString(" ")
			sb.WriteString(r.Name)
			sb.WriteString(" высота ")
			sb.WriteString(fmt.Sprintf("%f", r.Height))
			sb.WriteString(" вершин ")
			sb.WriteString(fmt.Sprintf("%d", len(r.Vertices)))
		}
	}
	if input.Walls != nil {
		lb := 0
		for _, w := range input.Walls {
			if w.LoadBearing {
				lb++
			}
		}
		sb.WriteString("; Стен всего ")
		sb.WriteString(fmt.Sprintf("%d", len(input.Walls)))
		sb.WriteString("; Несущих ")
		sb.WriteString(fmt.Sprintf("%d", lb))
	}
	if input.Constraints != nil {
		if len(input.Constraints.RegionRules) > 0 {
			sb.WriteString("; Правила: ")
			sb.WriteString(strings.Join(input.Constraints.RegionRules, ","))
		}
		if len(input.Constraints.ForbiddenMoves) > 0 {
			sb.WriteString("; Запреты: ")
			sb.WriteString(strings.Join(input.Constraints.ForbiddenMoves, ","))
		}
	}
	aiPrompt := sb.String()
	var aiAnalyze *assistant.BTIResponse
	var err error
	if v := ctx.Value("yandexAPIKey"); v != nil {
		if s, ok := v.(string); ok && strings.TrimSpace(s) != "" {
			aiAnalyze, err = assistant.AiAnalyzeWithKey(aiPrompt, s)
		}
	}
	if aiAnalyze == nil {
		aiAnalyze, err = assistant.AiAnalyze(aiPrompt)
	}
	log.Printf("AI prompt len: %d", len(aiPrompt))
	if err != nil || aiAnalyze == nil {
		log.Printf("AI analyze failed: %v", err)
	} else {
		log.Printf("AI decision: %s", aiAnalyze.Decision)
		if aiAnalyze.Decision != "" {
			decision = aiAnalyze.Decision
		}
	}
	db := r.DB

	// Пробуем получить userID из контекста (прокинут из заголовка X-User-Id)
	var userID int64 = 0
	if v := ctx.Value("userID"); v != nil {
		if s, ok := v.(string); ok {
			if parsed, err := strconv.ParseInt(strings.TrimSpace(s), 10, 64); err == nil && parsed > 0 {
				userID = parsed
			}
		}
	}
	// Если не удалось определить userID — используем существующего пользователя или создаём дефолтного
	if userID == 0 {
		//	var existing models.User
		//if err := db.First(&existing).Error; err != nil {
		// Создаём дефолтного пользователя
		//def := models.User{Login: "default", Password: "default", Username: "Default"}
		//if err := db.Create(&def).Error; err != nil {
		//log.Printf("failed to create default user: %v", err)
		//} else {
		//userID = def.ID
		//}
		//} else {
		//userID = existing.ID
		//}
		return nil, fmt.Errorf("user not found")

	}

	project := models.PlanningProject{
		User_id:           userID,
		Status:            decision,
		Address:           input.Plan.Address,
		Area:              fmt.Sprintf("%f", input.Plan.Area),
		Source:            input.Plan.Source,
		LayoutType:        input.Plan.LayoutType,
		FamilyProfile:     input.Plan.FamilyProfile,
		Goal:              input.Plan.Goal,
		Prompt:            input.Plan.Prompt,
		CeilingHeight:     fmt.Sprintf("%f", input.Plan.CeilingHeight),
		FloorDelta:        fmt.Sprintf("%f", input.Plan.FloorDelta),
		RecognitionStatus: input.Plan.RecognitionStatus,
		ClientTimestamp: func() string {
			if input.ClientTimestamp != nil {
				return *input.ClientTimestamp
			}
			return ""
		}(),
	}

	// Если пришёл файл плана — сохраняем метаданные
	if input.Plan.File != nil {
		project.PlanFileName = input.Plan.File.Name
		project.PlanFileSize = fmt.Sprintf("%f", input.Plan.File.Size)
		project.PlanFileType = input.Plan.File.Type
		project.PlanFileContent = input.Plan.File.Content
	}

	if err := db.Create(&project).Error; err != nil {
		return nil, fmt.Errorf("ошибка сохранения проекта: %w", err)
	}

	// --- 4. Сохраняем комнаты ---
	for _, roomInput := range input.Geometry.Rooms {
		room := models.Room{
			ProjectID: project.ID,
			Name:      roomInput.Name,
			Height:    fmt.Sprintf("%f", roomInput.Height),
		}
		if err := db.Create(&room).Error; err != nil {
			return nil, err
		}

		for _, v := range roomInput.Vertices {
			vertex := models.RoomVertex{
				RoomID: room.ID,
				X:      fmt.Sprintf("%f", v.X),
				Y:      fmt.Sprintf("%f", v.Y),
			}
			if err := db.Create(&vertex).Error; err != nil {
				return nil, err
			}
		}
	}

	// --- 5. Сохраняем стены ---
	for _, wallInput := range input.Walls {
		wall := models.Wall{
			ProjectID:   project.ID,
			StartX:      fmt.Sprintf("%f", wallInput.Start.X),
			StartY:      fmt.Sprintf("%f", wallInput.Start.Y),
			EndX:        fmt.Sprintf("%f", wallInput.End.X),
			EndY:        fmt.Sprintf("%f", wallInput.End.Y),
			LoadBearing: wallInput.LoadBearing,
			Thickness:   fmt.Sprintf("%f", wallInput.Thickness),
			WallType: func() string {
				if wallInput.WallType != nil {
					return *wallInput.WallType
				}
				return ""
			}(),
		}
		if err := db.Create(&wall).Error; err != nil {
			return nil, err
		}
	}

	// --- 6. Сохраняем ограничения, если есть ---
	if input.Constraints != nil {
		constraints := models.Constraints{
			ProjectID:      project.ID,
			ForbiddenMoves: strings.Join(input.Constraints.ForbiddenMoves, ","),
			RegionRules:    strings.Join(input.Constraints.RegionRules, ","),
		}
		if err := db.Create(&constraints).Error; err != nil {
			return nil, err
		}
	}

	// --- 7. Формируем GraphQL ответ с геометрией/стенами/ограничениями ---
	gqlProject := ConvertDbProjectToGraph(&project)
	if input.Geometry != nil {
		rooms := make([]*model.Room, 0, len(input.Geometry.Rooms))
		for _, r := range input.Geometry.Rooms {
			verts := make([]*model.Vertex, 0, len(r.Vertices))
			for _, vv := range r.Vertices {
				verts = append(verts, &model.Vertex{X: vv.X, Y: vv.Y})
			}
			rid := ""
			if r.ID != nil {
				rid = *r.ID
			}
			rooms = append(rooms, &model.Room{
				ID:       rid,
				Name:     r.Name,
				Height:   r.Height,
				Vertices: verts,
			})
		}
		gqlProject.Geometry = &model.Geometry{Rooms: rooms}
	}
	if input.Walls != nil {
		walls := make([]*model.Wall, 0, len(input.Walls))
		for _, w := range input.Walls {
			wid := ""
			if w.ID != nil {
				wid = *w.ID
			}
			walls = append(walls, &model.Wall{
				ID:          wid,
				Start:       &model.WallEnd{X: w.Start.X, Y: w.Start.Y},
				End:         &model.WallEnd{X: w.End.X, Y: w.End.Y},
				LoadBearing: w.LoadBearing,
				Thickness:   w.Thickness,
				WallType:    w.WallType,
			})
		}
		gqlProject.Walls = walls
	}
	if input.Constraints != nil {
		gqlProject.Constraints = &model.Constraints{
			ForbiddenMoves: input.Constraints.ForbiddenMoves,
			RegionRules:    input.Constraints.RegionRules,
		}
	}
	return gqlProject, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	uid, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user id")
	}

	var user_DataBase models.User

	if err := r.DB.First(&user_DataBase, uid).Error; err != nil {
		return nil, err
	}

	user_graphql := &model.User{
		Login:    user_DataBase.Login,
		Username: user_DataBase.Username,
		Email:    user_DataBase.Email,
	}

	return user_graphql, nil
}

// GetUserProject is the resolver for the getUserProject field.
func (r *queryResolver) GetUserProject(ctx context.Context, projectID string, userID string) (*model.PlanningProject, error) {
	var project models.PlanningProject

	pid, _ := strconv.ParseInt(projectID, 10, 64)
	uid, _ := strconv.ParseInt(userID, 10, 64)

	if err := r.DB.Where("id = ? AND user_id = ?", pid, uid).First(&project).Error; err != nil {
		return nil, fmt.Errorf("проект не найден или доступ запрещен")
	}

	return ConvertDbProjectToGraph(&project), nil
}

// GetUserProjects is the resolver for the getUserProjects field.
func (r *queryResolver) GetUserProjects(ctx context.Context, userID string) ([]*model.PlanningProject, error) {
	var dbProjects []models.PlanningProject

	var uid int64
	if _, err := fmt.Sscanf(userID, "%d", &uid); err != nil {
		return nil, fmt.Errorf("неверный формат ID пользователя")
	}
	projectsFilter := ""
	if v := ctx.Value("projectsFilter"); v != nil {
		if s, ok := v.(string); ok {
			projectsFilter = strings.ToLower(strings.TrimSpace(s))
		}
	}
	onlyApproved := false
	if v := ctx.Value("onlyApproved"); v != nil {
		if s, ok := v.(string); ok {
			if strings.EqualFold(strings.TrimSpace(s), "true") {
				onlyApproved = true
			}
		}
	}
	if err := r.DB.Where("user_id = ?", uid).
		Preload("Rooms").
		Preload("Rooms.Vertices").
		Preload("Walls").
		Preload("Constraints").
		Order("created_at DESC").
		Find(&dbProjects).Error; err != nil {
		return nil, fmt.Errorf("ошибка при поиске проектов: %w", err)
	}
	log.Printf("GetUserProjects: uid=%d filter=%s onlyApproved=%v total=%d", uid, projectsFilter, onlyApproved, len(dbProjects))

	// Конвертируем в GraphQL модели
	var graphQLProjects []*model.PlanningProject
	for i := range dbProjects {
		graphQLProjects = append(graphQLProjects, ConvertDbProjectToGraph(&dbProjects[i]))
	}
	if len(graphQLProjects) > 0 {
		sample := make([]string, 0, len(graphQLProjects))
		for i := 0; i < len(graphQLProjects) && i < 10; i++ {
			sample = append(sample, graphQLProjects[i].Status)
		}
		log.Printf("GetUserProjects: returning=%d statuses=%v", len(graphQLProjects), sample)
	} else {
		log.Printf("GetUserProjects: returning=0")
	}
	return graphQLProjects, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
